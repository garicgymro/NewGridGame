#!/usr/bin/python2
# -*- coding: utf-8 -*-
"""
title           :Client.py.

description     :Client software
author          :Gareth Roberts, Department of Linguistics,
                 University of Pennsylvania
                 Adpated for ZAS Berlin by Lisa Raithel and Jon Stevens
                 Adapted for Grid Game by Inthat Boonpongmanee
usage           :python run_client.py
notes           :Requires installation of wxPython
python_version  :2.7.7
"""

from __future__ import division
from __future__ import unicode_literals

import codecs
import json
import re
import socket
import sys
import threading
import random
import os
import ast
import math
import ujson

try:
    import wx
except ImportError:
    raise ImportError("The wxPython module is required to run this program")

# you need this one to shut down server and clients correctly
# from wx.lib.pubsub import pub
# import wx.lib.pubsub
# from wx.lib.pubsub import setupkwargs
from pubsub import pub
import wx.richtext as rt

import wx.grid

import wx.lib.colourdb

class Glbls():
    display_all_referents_to_speaker = True
    show_feedback_grid = True
    GridRowSize = 40
    GridColSize = 40
    grid_size = 12
    timeRounds = True
    displayTimer = True
    roundLength = 40 #in seconds
    minRoundLength = 20
    reduceRoundTime = True 
    roundTimeReduction = 0.5
    server_end_marker = "!!!%%%&&&!!!"
    practice_over = False




class GuiWindow(wx.Frame):
    """Construct the window(s) the participants of the experiment see."""
    def __init__(self, parent, id, title, host, name):
        """Initialise the GUI window for the participant.

        :param parent   :the parent of this window
        :type parent    :wx python object
        :param id       :id of the frame, assigned automatically
        :type id        :int
        :param title    :name of the current window
        :type title     :str
        :param host     :name of the host
        :type host      :str
        :param name     :the participant's name
        :type name      :str
        """
        self.bufsize = 4096
        self.host = host
        self.port = 8000

        """INITIALISING Glbls VARIABLES"""
        # name of the participant
        self.name = name
        # set self.ready to 1 by first message from server
        # (means all clients are connected)
        self.ready = 0
        # set stage and role of players
        self.stage = "pregame"
        self.role = "undecided"


        # Use this to randomly select a referent from our list
        # Create variables that point to each referent. We will select a random 8/12 for each phase. We also need
        # to make sure that the correct answer is present.
        self.referent_list = []

        # variable storing the referent
        self.referent_string = "empty"

        # Extract referent from radio buttons & from the speaker's message
        self.currentGuess = ""
        self.correctReferent = ""

        #set image size
        # self.image_width = 200
        # self.image_height = 200
        self.image_width = 250
        self.image_height = 250
        # server_end_marker must be the same as in the Server script
        # self.server_end_marker = "!!!%%%&&&!!!"
        # all elements of all sizers are collected in this list
        self.elements_in_sizer = []
        # path to instructions file given by a server message
        self.instructions_file = ""
        # the image file(s)
        self.image_buttons_1 = ""
        self.image_buttons_2 = ""
        self.image_buttons_3 = ""
        self.image_buttons_4 = ""
        self.image_buttons_5 = ""
        self.image_buttons_6 = ""
        self.image_buttons_7 = ""
        self.image_buttons_8 = ""
        self.image_buttons_9 = ""
        self.image_buttons_10 = ""
        self.image_buttons_11 = ""
        self.image_buttons_12 = ""

        self.chosen_pic = ""
        self.alt_pic = ""
        self.listener_chosen_pic = ""
        self.pic_for_displaying = ""
        # score
        self.score = 0
        self.round_counter = 0
        # path to the image directory
        self.image_path = ""
        # collect all sizer elements for clearing them in one
        # speaker and listener number for getting the right pairs
        self.speaker_no = ""
        self.listener_no = ""
        # during the practice rounds, each client only has a
        # participant number without a role
        self.participant_no = ""
        # answers of the survey
        self.survey_answers = ""
        # size of the submit buttons
        self.submit_button_size = (500, -1)
        # the sentences generated by the speaker are added to this list
        # the message decides which state or stage is taken
        self.submitted_message = {"msg":None}
        self.round_info = ""
        # self.practice_over = False

        self.AllowErase = True
        self.GridWidth = 12
        self.GridHeight = 12



        """SERVER MESSAGES"""
        # identifies special messages from the Server


        # List of 8 referents from the server
        self.refList = [];

        self.srvr_msg = re.compile(r'9999.*9999(?!\s)')
        self.kill_msg = re.compile(r".*KILL.*")
        # transfers start of all clients, path to images and client number
        self.begin_msg = re.compile(r'9999BEGIN(.*)@(.*)@(.*)@(.*)@(.*)9999(?!\s)')
        # tranfers message from listener: listener number and round info
        self.listener_msg = re.compile(r'9999LISTENER(.*)_(.*)9999(?!\s)')
        self.listener_buttons_msg = re.compile(r"9999BUTTONS_LISTENER(.*)@(.*)@(.*)9999")
        # identifies message from speaker: current image, speaker number
        # and round info
        self.speaker_buttons_msg = re.compile(r"9999BUTTONS_SPEAKER(.*)@(.*)@(.*)9999")
        # a message that is directed to all participants
        self.msg_for_all = re.compile(r"9999ALL(.*)@(.*)@(.*)9999(?!\s)")
        # message that identifies the beginning of the experiment
        # (welcome page)
        self.welcome_msg = re.compile(r"9999WELCOME(.*)9999(?!\s)")
        # message for listener: the chosen picture
        self.pic_from_speaker = re.compile(r"9999PIC(.*)9999(?!\s)")
        # listener response: the guessed picture
        self.pic_from_listener = re.compile(r"9999GUESS(.*)9999(?!\s)")
        # coordinates
        self.coords_from_speaker = re.compile(r"9999COORD(.*)@(.*)9999(?!\s)")



        # initialise the gui frame
        no_resize = wx.DEFAULT_FRAME_STYLE & ~ (wx.RESIZE_BORDER |
                                                wx.MAXIMIZE_BOX)
                                                #wx.RESIZE_BOX |


        wx.Frame.__init__(self, parent, id, title="Communication Experiment",
                          size=wx.DisplaySize())
        # create the main sizer
        self.main_ver_sizer = wx.BoxSizer(wx.VERTICAL)

        self.Show()

        self.SetSizer(self.main_ver_sizer)

        self.Layout()
        self.SetBackgroundColour("WHITE")

        threads = []
        self.threads = threads
        self.Bind(wx.EVT_CLOSE, self.on_exit_app)

        # connect the client to the server
        self.connect_to_server()

        self.threads.append(Reader(self.srvsock, self))
        for thread in self.threads:
            # stops when everything else does
            thread.daemon = True
            thread.start()


    # after each window remove the displayed
    # elements from the sizer (not only hide them)
    def remove_elements_from_sizer(self):
        """Remove all elements that were stored in the sizer."""

        for element in self.elements_in_sizer:
            try:
                element.Hide()
                element.Destroy()
            except:
                pass
        self.main_ver_sizer.Clear()


        self.elements_in_sizer = []
        self.Layout()

    def adjust_dimensions(self, im):
        """Adjust the dimension of a given image."""
        width = im.GetWidth()
        height = im.GetHeight()
        ratio = float(width) / float(height)

        newwidth = self.image_width * ratio
        newheight = self.image_height
        return((newwidth, newheight))

    def welcome_stage(self):
        """The first page of the experiment -- welcomes participant."""
        dummy_panel_1 = DummyPanel(self)
        dummy_panel_1.SetBackgroundColour("RED")
        welcome_panel = WelcomePage(self)
        dummy_panel_2 = DummyPanel(self)
        dummy_panel_2.SetBackgroundColour("BLUE")

        self.main_ver_sizer.Add(dummy_panel_1, 1, wx.ALIGN_CENTER)
        self.main_ver_sizer.Add(welcome_panel, 0, wx.ALIGN_CENTER)
        self.main_ver_sizer.Add(dummy_panel_2, 1, wx.ALIGN_CENTER)

        self.SetSizer(self.main_ver_sizer)
        self.Layout()
        self.Show()

    def survey_stage(self):
        """The questionnaire stage."""
        self.stage = "survey"
        dummy_panel_1 = DummyPanel(self)
        questionnaire_panel = QuestionnairePage(self)
        dummy_panel_2 = DummyPanel(self)

        self.main_ver_sizer.Add(dummy_panel_1, 1, wx.ALIGN_CENTER)
        self.main_ver_sizer.Add(questionnaire_panel, 0, wx.ALIGN_CENTER)
        self.main_ver_sizer.Add(dummy_panel_2, 1, wx.ALIGN_CENTER)

        self.SetSizer(self.main_ver_sizer)
        self.Layout()

    def instruction_stage(self):
        """Display a page with instructions."""
        self.stage = "instructions"

        dummy_panel_1 = DummyPanel(self)
        instructions_panel = InstructionsPage(self)
        dummy_panel_2 = DummyPanel(self)

        self.main_ver_sizer.Add(dummy_panel_1, 1, wx.ALIGN_CENTER)
        self.main_ver_sizer.Add(instructions_panel, 0, wx.ALIGN_CENTER)
        self.main_ver_sizer.Add(dummy_panel_2, 1, wx.ALIGN_CENTER)

        self.SetSizer(self.main_ver_sizer)
        self.Layout()

    def speaker_buttons_stage(self):
        """Create a speaker panel for displaying the image.  (NOT IN USE)"""
        self.role = "speaker"
        dummy_panel_1 = DummyPanel(self)
        speaker_panel = SpeakerButtonsPanel(self)
        dummy_panel_2 = DummyPanel(self)

        self.main_ver_sizer.Add(dummy_panel_1, 1, wx.ALIGN_CENTER)
        self.main_ver_sizer.Add(speaker_panel, 0, wx.ALIGN_CENTER)
        self.main_ver_sizer.Add(dummy_panel_2, 1, wx.ALIGN_CENTER)

        self.SetSizer(self.main_ver_sizer)
        self.Layout()
        self.elements_in_sizer.append(speaker_panel)

    def speaker_draw_stage(self):
        """Stage were speaker has to 'draw' the line on the grid."""
        print("In speaker_draw_stage")
        self.role = "speaker"
        # self.speaker_sizer = wx.BoxSizer(wx.HORIZONTAL)

        dummy_panel_1 = DummyPanel(self)
        drawing_panel = DrawingPage(self)
        dummy_panel_2 = DummyPanel(self)
        # referents_panel = SpeakerReferentsListPanel(self)


        self.main_ver_sizer.Add(dummy_panel_1, 1, wx.ALIGN_CENTER)
        self.main_ver_sizer.Add(drawing_panel, 0, wx.ALIGN_CENTER)
        self.main_ver_sizer.Add(dummy_panel_2, 1, wx.ALIGN_CENTER)

        self.SetSizer(self.main_ver_sizer)
        self.Layout()
        self.elements_in_sizer.append(drawing_panel)
        # if Glbls.display_all_referents_to_speaker == True:
        #     self.elements_in_sizer.append(referents_panel)



    def listener_idle_stage(self):
        """Display a temporary message for the listener."""
        # assign role to client
        self.role = "listener"
        # print("In listener_idle_stage")

        msg = "You are waiting on a message from your partner."

        dummy_panel_1 = DummyPanel(self)
        message_panel = MessagePanel(self, msg)
        dummy_panel_2 = DummyPanel(self)

        self.main_ver_sizer.Add(dummy_panel_1, proportion=1, flag=wx.ALIGN_CENTER)
        self.main_ver_sizer.Add(message_panel, proportion=0, flag=wx.ALIGN_CENTER)
        self.main_ver_sizer.Add(dummy_panel_2, proportion=1, flag=wx.ALIGN_CENTER)

        self.SetSizer(self.main_ver_sizer)
        self.Layout()
        self.elements_in_sizer.append(message_panel)

    def speaker_idle_stage(self,coords):
        """Display a temporary message for the listener."""
        


        if Glbls.show_feedback_grid == True:
            msg = "You are waiting on a guess from your partner.\n Here is what they received:\n"
            
            feedback_panel = FeedbackPage(self,coords)
        else:
            feedback_panel = dummy_panel_2
            msg = "You are waiting on a guess from your partner.\n\n"

        
        dummy_panel_1 = DummyPanel(self) 
        message_panel = MessagePanel(self, msg)
        dummy_panel_2 = DummyPanel(self)

        # self.main_ver_sizer.Add(dummy_panel_1, 1, wx.ALIGN_CENTER)
        self.main_ver_sizer.Add(dummy_panel_1, 1, wx.ALIGN_CENTER)
        self.main_ver_sizer.Add(message_panel, 0, wx.ALIGN_CENTER)
        self.main_ver_sizer.Add(feedback_panel, 1, wx.ALIGN_CENTER)


        self.SetSizer(self.main_ver_sizer)
        self.Layout()
        self.elements_in_sizer.append(message_panel)
        self.elements_in_sizer.append(feedback_panel)

    def round_feedback_stage(self):
        """Display the picture chosen by each player."""
        # print("**in round_feedback_stage**")
        # print("role of client: ", self.role)
        if Glbls.practice_over == False:
            if str(self.listener_pic_for_displaying) == str(self.correctReferent): #This doesn't mean anything ... !!!
                # print("listener's guess, received from server (=currentGuess):", self.listener_pic_for_displaying)
                # print("Speaker's referent label:")
                if self.role == "speaker":
                    msg = "They correctly picked \"" + str(self.correctReferent) + "\"! Well done!\n"
                else:
                    msg = "\"" + str(self.correctReferent) + "\" was correct! Well done!\n"
                # print("previous score", self.score)
                self.score += 1
                # print("practice score increased by 1!", self.score)
                # print("**exit round_feedback_stage**")
            else:
                if self.role == "speaker":
                    msg = "They got it wrong! They picked \"" + str(self.listener_pic_for_displaying) + "\" instead of \"" + str(self.correctReferent) + "\".\n"
                else:
                    msg = "You got it wrong! The correct answer was \"" + str(self.correctReferent) + "\"." + " However, you picked \"" + str(self.listener_pic_for_displaying) + "\".\n"
        else:
            self.round_counter += 1
            if str(self.listener_pic_for_displaying) == str(self.correctReferent):
                self.score += 1
                # print("real score:", self.score)
                # print("role:", self.role)
                if self.role == "speaker":
                    msg = "They correctly picked \"" + str(self.correctReferent) + "\"! Well done!\n"
                else:
                    msg = "\"" + str(self.correctReferent) + "\" was correct! Well done!\n"
            else:
                if self.role == "speaker":
                    msg = "They got it wrong! They picked \"" + str(self.listener_pic_for_displaying) + "\" instead of \"" + str(self.correctReferent) + "\".\n"
                else:
                    msg = "You got it wrong! The correct answer was \"" + str(self.correctReferent) + "\"." + " However, you picked \"" + str(self.listener_pic_for_displaying) + "\".\n"

        dummy_panel_1 = DummyPanel(self)

        if self.role == "listener":
            if self.swap:
                self.role = "speaker"
                self.submitted_message = {"msg":"next round"}
                message_panel = MessagePanel(self, msg, "OK")
            else:
                message_panel = MessagePanel(self,msg)
        elif self.role == "speaker":
            if self.swap:
                self.role = "listener"
                message_panel = MessagePanel(self,msg)
            else:
                self.submitted_message = {"msg":"next round"}
                message_panel = MessagePanel(self, msg, "OK")

        dummy_panel_2 = DummyPanel(self)

        self.main_ver_sizer.Add(dummy_panel_1, 1, wx.ALIGN_CENTER)
        self.main_ver_sizer.Add(message_panel, 0, wx.ALIGN_CENTER)
        self.main_ver_sizer.Add(dummy_panel_2, 1, wx.ALIGN_CENTER)

        self.SetSizer(self.main_ver_sizer)
        self.Layout()
        self.elements_in_sizer.append(message_panel)

    def listener_choice_stage(self):
        # Take a guess at what the speaker meant
        dummy_panel_1 = DummyPanel(self)
        listener_panel = ListenerButtonsPanel(self)
        dummy_panel_2 = DummyPanel(self)

        self.main_ver_sizer.Add(dummy_panel_1, 1, wx.ALIGN_CENTER)
        self.main_ver_sizer.Add(listener_panel, 0, wx.ALIGN_CENTER)
        self.main_ver_sizer.Add(dummy_panel_2, 1, wx.ALIGN_CENTER)

        self.SetSizer(self.main_ver_sizer)
        self.Layout()
        self.elements_in_sizer.append(listener_panel)

    def result_stage(self):
        """Display last message and give opportunity to close frame."""
        self.stage = "game over"
        percentage_score = str(int(round((float(self.score)/float(self.round_counter))*100)))+"%"
        msg = "Your final score is %s\nThank you for participating!" % percentage_score
        dummy_panel_1 = DummyPanel(self)
        message_panel = MessagePanel(self, msg, "close")
        dummy_panel_2 = DummyPanel(self)

        self.main_ver_sizer.Add(dummy_panel_1, 1, wx.ALIGN_CENTER)
        self.main_ver_sizer.Add(message_panel, 0, wx.ALIGN_CENTER)
        self.main_ver_sizer.Add(dummy_panel_2, 1, wx.ALIGN_CENTER)

        self.SetSizer(self.main_ver_sizer)
        self.Layout()
        self.elements_in_sizer.append(message_panel)


    def encode_msg(self, item):
        """Encode a message for the sever."""
        encoded_item = item.encode("utf-8") + Glbls.server_end_marker.encode("utf-8")
        # encoded_item = item.encode() + self.server_end_marker.encode()
        print("encoded item: ", encoded_item)
        return(encoded_item)

    def submit_message(self):
        print("submitted_message: ", self.submitted_message)
        """Send messages to server and/or go to another stage."""
        # remove all elements from the sizer to be able to establish
        # new items
        self.remove_elements_from_sizer()

        if self.ready == 1:
            if self.stage == "instructions":
                msg = """Thank you!\n\nThe practice rounds will start\n\nwhen all participants are ready."""

                dummy_panel_1 = DummyPanel(self)
                message_panel = MessagePanel(self, msg)
                dummy_panel_2 = DummyPanel(self)

                self.main_ver_sizer.Add(dummy_panel_1, 1, wx.ALIGN_CENTER)
                self.main_ver_sizer.Add(message_panel, 0, wx.ALIGN_CENTER)
                self.main_ver_sizer.Add(dummy_panel_2, 1, wx.ALIGN_CENTER)

                self.SetSizer(self.main_ver_sizer)
                self.Layout()
                self.elements_in_sizer.append(message_panel)

                # utterance = "6666INSTRUCTIONSREAD@" + self.name + "@6666"
                msg_to_send = ujson.dumps({"msg":"instructions read","name":self.name})
                encoded_message = self.encode_msg(msg_to_send)
                self.srvsock.send(encoded_message)
                self.stage = ""

            elif self.stage == "survey":
                msg = """Please wait one moment, until all participants are ready.\n\nThe instructions will be presented to you shortly."""

                dummy_panel_1 = DummyPanel(self)
                message_panel = MessagePanel(self, msg)
                dummy_panel_2 = DummyPanel(self)

                self.main_ver_sizer.Add(dummy_panel_1, 1, wx.ALIGN_CENTER)
                self.main_ver_sizer.Add(message_panel, 0, wx.ALIGN_CENTER)
                self.main_ver_sizer.Add(dummy_panel_2, 1, wx.ALIGN_CENTER)

                self.SetSizer(self.main_ver_sizer)
                self.Layout()
                self.elements_in_sizer.append(message_panel)
                msg_to_send = ujson.dumps({"msg":"survey completed","name":self.name,"survey answers":self.survey_answers})
                # message = ("6666SURVEYCOMPLETED@" + self.name + "@" + self.survey_answers +
                #            "@6666")
                encoded_message = self.encode_msg(msg_to_send)
                self.srvsock.send(encoded_message)

                self.stage = ""

            elif self.stage == "practice over":
                Glbls.practice_over = True
                msg = """The practice rounds are now completed.\n\nIf you have questions,
please ask the experimenter.\n\nThe experiment will begin when everyone is ready."""

                dummy_panel_1 = DummyPanel(self)
                message_panel = MessagePanel(self, msg, "OK")
                dummy_panel_2 = DummyPanel(self)

                self.submitted_message = {"msg":"ready to start proper rounds","name":self.name}
                # "6666READYTOSTARTPROPERROUNDS@" + self.name + "@6666"
                self.stage = ""

                self.main_ver_sizer.Add(dummy_panel_1, 1, wx.ALIGN_CENTER)
                self.main_ver_sizer.Add(message_panel, 0, wx.ALIGN_CENTER)
                self.main_ver_sizer.Add(dummy_panel_2, 1, wx.ALIGN_CENTER)

                self.SetSizer(self.main_ver_sizer)
                self.Layout()
                self.elements_in_sizer.append(message_panel)

            elif self.submitted_message["msg"] == "ready to start proper rounds":
                msg_to_send = ujson.dumps(self.submitted_message)
                encoded_message = self.encode_msg(msg_to_send)
                self.srvsock.send(encoded_message)


            elif self.submitted_message["msg"] == "submit score":
                msg_to_send = ujson.dumps({"msg":"score","score":self.score})
                encoded_message = self.encode_msg(msg_to_send)
                self.srvsock.send(encoded_message)

            elif self.submitted_message["msg"] == "next round":
                msg_to_send = ujson.dumps(self.submitted_message)
                encoded_message = self.encode_msg(msg_to_send)
                self.srvsock.send(encoded_message)

            elif self.role == "speaker":

                if self.submitted_message["msg"] == "pic chosen": #(NOT IN USE)

                    msg_to_send = ujson.dumps({"msg":"pic","chosen pic":self.chosen_pic,"name":self.name})
                    encoded_message = self.encode_msg(msg_to_send)
                    self.srvsock.send(encoded_message)

                # elif type(self.submitted_message) == list:
                elif self.submitted_message["msg"] == "coords":
                    msg_to_send = ujson.dumps({"msg":"coords","coords":self.submitted_message["coords"],"name":self.name,"referent":self.referent_string})
                    # utterance = ("6666COORD" + str(self.submitted_message) + "@" +
                                # self.name + "@" + self.referent_string + "@" + str(6666))

                    print("speaker's correct answer: referent_string", self.referent_string)
                    encoded_message = self.encode_msg(msg_to_send)
                    self.srvsock.send(encoded_message)

                elif self.submitted_message["msg"] == "still choosing":
                    self.speaker_buttons_stage()

                else:
                    pass

            elif self.role == "listener":
                if self.submitted_message["msg"] == "listener pic chosen":
                    msg_to_send = ujson.dumps({"msg":"guess","listener chosen pic":self.listener_chosen_pic,"name":self.name,"correct referent":self.correctReferent})
                    # utterance = ("6666GUESS" + self.listener_chosen_pic + "@" + self.name + "@" +
                                 # self.correctReferent + "@" + str(6666))
                    # print("listener's chosen referent sent to server as encoded string:",utterance)
                    encoded_message = self.encode_msg(msg_to_send)
                    self.srvsock.send(encoded_message)

                elif self.submitted_message["msg"] == "listener still choosing":
                    self.listener_choice_stage()


                else:
                    pass

            elif self.stage == "game over":
                msg_to_send = ujson.dumps({"msg":"closed"})
                encoded_message = self.encode_msg(msg_to_send)
                self.srvsock.send(encoded_message)

                self.Destroy()
                sys.exit()

        else:
            # TODO: throw exception
            print("something weird is happening")
            pass

    def incoming_message(self, message):
        """Function for receiving messages from the server.

        The messages are matched with the
        regular expressions defined in __init__.
        Each message is a trigger for a state.

        :param message: the incoming message.
        :type message: str.
        """
        # print("\n\n\nnew incoming message: ", message)
        
        self.remove_elements_from_sizer()

        loaded_msg = ujson.loads(message)

        msg_type = loaded_msg["msg"]
        # print("\nloaded message: ", loaded_msg)

        # if re.match(self.srvr_msg, message):
        if msg_type == "kill":
            killmessage = ujson.dumps({"msg":"kill"})
            encoded_killmessage = self.encode_msg(killmessage)
            self.srvsock.send(encoded_killmessage)
            self.close_up()

        elif msg_type == "welcome":
            self.randomization = loaded_msg["randomization"]
            self.hard_mode = loaded_msg["hard mode"]
            # self.randomization = (m.group(1).split("@")[0] == "True")
            # self.hard_mode = (m.group(1).split("@")[1] == "True")
            self.input_type = "dropdown"
            # go to welcome stage
            # self.input_type = "text entry"
            self.welcome_stage()

        # elif re.match(self.msg_for_all, message):
        #     m = re.match(self.msg_for_all, message)
        #     msg = m.group(1)
        #     print("in msg_for_all -> m.group(1) = ",msg)
        #     additional_msg = m.group(2)
        #     print("in msg_for_all -> m.group(2) = ", msg)

        # get image and participant number

        #IS THIS IMPORTANT
        # if "{" in additional_msg:
        #     temp_dict = json.loads(additional_msg)
        #     self.participant_no = temp_dict["player"]
        #     del temp_dict["player"]
        #     self.image_dict = temp_dict

        # if msg == "IMAGEPATH":
            # self.image_path = additional_msg

        elif msg_type == "instructions":
            self.instruction_stage()

        elif msg_type == "practice round":
            # print("I AM IN PRACTICEROUND")
            self.image_buttons_1 = loaded_msg["image1"]
            # self.image_buttons_1 = additional_msg.split("=")[0]
            # self.image_buttons_2 = additional_msg.split("=")[1]
            self.image_buttons_2 = loaded_msg["image2"]
            self.chosen_pic = self.image_buttons_1
            self.alt_pic = self.image_buttons_2
            self.pic_for_displaying = self.chosen_pic

            # Read in the referent list determined by the server
            self.referent_list = loaded_msg["reflist"]
            # self.referent_list = self.referent_list.split(", ")
            print("referent_list sent directly from server", self.referent_list)

            if self.role == "speaker":
                print("I AM IN PRACTICEROUND")
                # image_string = "6666" + self.chosen_pic + "|||" + self.alt_pic + "6666"
                # print("WHY IS THIS A PIC? SHOULDN'T BE HERE", image_string)
                # encoded_string = self.encode_msg(image_string)
                # self.srvsock.send(encoded_string)
                # utterance = ("6666PIC" + self.chosen_pic + "@" + self.name + "@" + str(6666))
                # encoded_message = self.encode_msg(utterance)
                # self.srvsock.send(encoded_message)
                #self.speaker_buttons_stage()

                self.speaker_draw_stage()

            elif self.role == "listener":
                print("I AM IN PRACTICEROUND")
                self.listener_idle_stage()

        elif msg_type == "proper round":
            self.stage = "game"
            # self.image_buttons_1 = additional_msg.split("=")[0]
            # self.image_buttons_2 = additional_msg.split("=")[1]
            # self.chosen_pic = self.image_buttons_1
            # self.alt_pic = self.image_buttons_2
            # self.pic_for_displaying = self.chosen_pic
            # Read in the referent list determined by the server
            self.referent_list = loaded_msg["reflist"]
            # self.referent_list = self.referent_list.split(", ")
            if (self.role == "speaker" 
                and (Glbls.reduceRoundTime == True 
                    and Glbls.roundLength > Glbls.minRoundLength
                    and Glbls.practice_over == True)):
                Glbls.roundLength -= Glbls.roundTimeReduction

                print("I AM IN PROPERROUND")
                # image_string = "6666" + self.chosen_pic + "|||" + self.alt_pic + "6666"
                # encoded_string = self.encode_msg(image_string)
                # self.srvsock.send(encoded_string)
                # utterance = ("6666PIC" + self.chosen_pic + "@" + self.name + "@" + str(6666))
                # encoded_message = self.encode_msg(utterance)
                # self.srvsock.send(encoded_message)
                # #self.speaker_buttons_stage()
                self.speaker_draw_stage()
            elif self.role == "listener":
                print("I AM IN PROPERROUND")
                self.listener_idle_stage()

        elif msg_type == "practice over":
            self.stage = "practice over"
            self.submit_message()

            # else:
            #     print("message in WEIRD MESSAGE", msg)
            #     print("WEIRD MESSAGE")

        # elif re.match(self.speaker_buttons_msg, message):

        #     m = re.match(self.speaker_buttons_msg, message)

        #     self.speaker_no = m.group(1)
        #     self.image_buttons_1 = m.group(2)
        #     self.image_buttons_2 = m.group(3)

        #     self.speaker_buttons_stage()

        # elif re.match(self.listener_buttons_msg, message):

        #     m = re.match(self.listener_buttons_msg, message)

        #     self.listener_no = m.group(1)
        #     self.image_buttons_1 = m.group(2)
        #     self.image_buttons_2 = m.group(3)

        #     self.listener_idle_stage()

        # elif re.match(self.listener_msg, message):
        #     m = re.match(self.listener_msg, message)

        #     self.listener_no = m.group(1)

        #     self.round_info = m.group(2)
        #     self.listener_idle_stage()

        # elif re.match(self.pic_from_speaker, message):
        #     m = re.match(self.pic_from_speaker, message)
        #     self.pic_for_displaying = m.group(1)

        elif msg_type == "guess":
            self.listener_pic_for_displaying = loaded_msg["guess"]
            self.round_feedback_stage()

        elif msg_type == "coords":

            self.speaker_coords = loaded_msg["filled array"]

            self.correctReferent = loaded_msg["referent"]
            print("correct referent (sent from speaker): ", self.correctReferent)
            if self.role == "listener":
                self.listener_choice_stage()
            else:
                self.speaker_idle_stage(coords=self.speaker_coords)

        elif msg_type == "only one player ready":
            if self.stage != "game":
                msg = """Waiting on the other player..."""

                dummy_panel_1 = DummyPanel(self)
                message_panel = MessagePanel(self, msg)
                dummy_panel_2 = DummyPanel(self)

                self.main_ver_sizer.Add(dummy_panel_1, 1, wx.ALIGN_CENTER)
                self.main_ver_sizer.Add(message_panel, 0, wx.ALIGN_CENTER)
                self.main_ver_sizer.Add(dummy_panel_2, 1, wx.ALIGN_CENTER)

                self.SetSizer(self.main_ver_sizer)
                self.Layout()
                self.elements_in_sizer.append(message_panel)

        elif msg_type == "game over":
            self.submitted_message = {"msg":"submit score"}
            self.submit_message()
            self.result_stage()

        elif msg_type == "begin":


            # m is the string list, group() returns tuple of specified index?
            self.client_number = loaded_msg["client number"]
            self.image_path = loaded_msg["image path"]
            self.ClickThreshold = loaded_msg["num clicks"]
            Glbls.roundLength = loaded_msg["time per round"]
            Glbls.minRoundLength = loaded_msg["min time per round"]
            Glbls.reduceRoundTime = loaded_msg["reduce round time"]
            Glbls.roundTimeReduction = loaded_msg["round time reduction"]
            swap_param = loaded_msg["swapping"]
            # print("swap_param",swap_param)
            if swap_param == True:
                # print("swapping!!!")
                self.swap = True
            else:
                # print("Not swapping...")
                self.swap = False

            if self.client_number == 0:
                self.role = "speaker"
                self.instructions_file = "instructions_S.txt"
            elif self.client_number == 1:
                self.role = "listener"
                self.instructions_file = "instructions_L.txt"

            if self.swap:
                self.instructions_file = "instructions.txt"

            if self.ready == 0:
                self.ready = 1

            self.welcome_stage()

        else:
            # TODO: throw exception
            print("I can't do anything with this message:",
                  loaded_msg)









    def on_submit(self, event):
        """Send a submit message."""
        self.submit_message()

    def connect_to_server(self):
        """Connect the client to the server."""
        srvsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.srvsock = srvsock
        srvsock.connect((self.host.strip(), self.port))
        # participant_info = "6666INFO" + self.name + "6666"
        msg_to_send = ujson.dumps({"msg":"info","name":self.name})
        print("sending info message!")
        encoded_info = self.encode_msg(msg_to_send)
        srvsock.send(encoded_info)
        print("info message sent!")

    def close_up(self):
        """Close everything."""
        self.srvsock.close()
        msg = "closing client"
        pub.sendMessage("clientclosed", data=msg)
        self.Destroy()
        sys.exit()

        # comment this section out if you don't want run_client to remember
        # the ip next time
        # try:
        # os.remove('temp_ip')
        # except(WindowsError):
        # pass

    def on_exit_app(self, event):
        """A dummy function that runs if user tries to close the gui."""
        pass

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
QUESTIONNAIRE PAGE
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""


class QuestionnairePage(wx.Panel):
    """Panel for the questionnaire."""

    def __init__(self, parent):
        """Initialise panel."""
        # variables for survey
        self.all_survey_questions = []
        self.survey_dict = {"Languages spoken": "",
                            "Favorite Pokemon": ""}
        self.survey_answer_boxes = {}

        # initialise panel
        wx.Panel.__init__(self, parent)
        self.box_sizer = wx.BoxSizer(wx.VERTICAL)

        self.gui = parent

        # initialise error message
        self.error_message_show = False

        self.warning_pos = 0
        self.error_message = wx.StaticText(self, wx.ID_ANY, "")
        self.error_message.SetFont(wx.Font(10, wx.DEFAULT,
                                   wx.NORMAL, wx.BOLD))
        self.error_message.SetForegroundColour(wx.RED)

        self.gui.elements_in_sizer.append(self.error_message)

        self.add_survey_questions()
        self.add_survey_submit_button()

        self.SetSizer(self.box_sizer)
        # self.box_sizer.Fit(self)
        self.box_sizer.Layout()
        self.Center()

    def add_survey_questions(self):
        """Add survey questions to the window."""
        text_1 = "Please begin by answering the following questions.\n\n"

        start_text = wx.StaticText(self, label=text_1)
        start_text.SetFont(wx.Font(14, wx.DEFAULT, wx.NORMAL,
                                   wx.BOLD))
        self.all_survey_questions.append(start_text)

        # question 1
        question_1_text = "\n1. Languages spoken\n"
        question_1 = wx.StaticText(self, label=question_1_text)
        question_1.SetFont(wx.Font(11, wx.DEFAULT, wx.NORMAL,
                                   wx.NORMAL))
        self.all_survey_questions.append(question_1)

        # answer 1
        language_box = wx.TextCtrl(self, id=wx.ID_ANY, size=(150, 30),
                                style=wx.TE_MULTILINE)
        self.all_survey_questions.append(language_box)
        self.survey_answer_boxes["Languages spoken"] = language_box

        # question 2
        question_2_text = "\n2. Favourite Pokemon\n"
        question_2 = wx.StaticText(self, label=question_2_text)
        question_2.SetFont(wx.Font(11, wx.DEFAULT, wx.NORMAL,
                                   wx.NORMAL))
        self.all_survey_questions.append(question_2)

        # answer 2
        study_box = wx.TextCtrl(self, id=wx.ID_ANY, size=(150, 30),
                                style=wx.TE_MULTILINE)
        self.all_survey_questions.append(study_box)
        self.survey_answer_boxes["Favourite Pokemon"] = study_box

        dummy_1 = wx.StaticText(self, label="")

        # # collect all objects in list
        # add all items to the sizer
        self.box_sizer.Add(start_text, 0)
        self.box_sizer.Add(question_1, 0)
        self.box_sizer.Add(language_box, 0)
        self.box_sizer.Add(dummy_1, 0)
        self.box_sizer.Add(question_2, 0)
        self.box_sizer.Add(study_box, 0)

        for question in self.all_survey_questions:
            question.Show()
            self.gui.elements_in_sizer.append(question)

    def add_survey_submit_button(self):
        """Add the submit button for the questionnaire."""
        label = "Submit"
        submit_button = wx.Button(self, id=wx.ID_ANY,
                                  label=label,
                                  size=self.gui.submit_button_size)

        dummy = wx.StaticText(self, label="")

        self.box_sizer.Add(dummy, 0)

        self.box_sizer.Add(self.error_message, 0)
        self.error_message.Hide()
        self.box_sizer.Add(submit_button, 0)

        submit_button.Bind(wx.EVT_BUTTON, self.on_survey_submit)
        submit_button.Show()
        self.gui.elements_in_sizer.append(submit_button)

    def on_survey_submit(self, event):
        """Check if all required answers were given and proceeds."""
        if self.get_survey_answers():
            self.Hide()
            self.gui.submit_message()

    def on_survey_text_box(self, key):
        for que, answer in self.survey_answer_boxes.items():
            if que == key:
                return(str(answer.GetValue()))

    def get_survey_answers(self):
        """Get answers of questionnaire."""
        # get answers from survey questions
        # question 3, 4
        study = self.on_survey_text_box("Favourite Pokemon")
        if study == "":
            self.survey_dict["Favourite Pokemon"] = "none given"
        else:
            self.survey_dict["Favourite Pokemon"] = self.on_survey_text_box("Favourite Pokemon")

        language = self.on_survey_text_box("Languages spoken")
        #if language == "":
        #    if not self.error_message_show:

        #        warning = """Please supply your Languages spoken."""
        #        self.add_warning(warning)
        #        self.error_message_show = True

        #    return(False)
        #else:
        if 1 == 1: # <--delete this line if block above is reinstated
            if language == "":
                self.survey_dict["Languages spoken"] = "none given"
            else:
                self.survey_dict["Languages spoken"] = self.on_survey_text_box("Languages spoken")

            answers = []
            for qu, answ in self.survey_dict.items():
                string = qu + ": " + answ #.decode('utf-8')
                answers.append(string)
            self.gui.survey_answers = ", ".join(answers)
            return(True)

    def add_warning(self, warning):
        """Display a warning message."""
        # if there are already displayed warnings
        # hide them
        if self.error_message_show:
            self.error_message.Hide()

        self.error_message.SetLabel(warning)
        self.error_message.Show()
        self.box_sizer.Layout()


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
WELCOME PAGE
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""


class WelcomePage(wx.Panel):
    """Panel for the welcome page."""

    def __init__(self, parent):
        """Initialise panel with welcome message."""
        wx.Panel.__init__(self, parent)
        # Glbls.grid_sizer = wx.GridBagSizer()
        self.box_sizer = wx.BoxSizer(wx.VERTICAL)

        self.gui = parent
        welcome_text = "Welcome!\n"

        introduction_text = """Please click start when you're ready\n\n\n"""

        welcome = wx.StaticText(self, label=welcome_text)

        welcome.SetFont(wx.Font(14, wx.DEFAULT, wx.NORMAL,
                                wx.BOLD))
        welcome.Show()

        introduction = wx.StaticText(self, label=introduction_text)

        introduction.SetFont(wx.Font(11, wx.DEFAULT, wx.NORMAL,
                             wx.NORMAL))
        introduction.Show()

        self.box_sizer.Add(welcome, 0)
        self.box_sizer.Add(introduction, 0)

        self.gui.elements_in_sizer.extend([welcome, introduction])
        self.add_welcome_submit_button()

        self.SetSizer(self.box_sizer)
        # self.box_sizer.Fit(self)
        self.box_sizer.Layout()
        self.Center()

    def add_welcome_submit_button(self):
        """Add submit button for very first page."""
        label = "Start"
        submit_button = wx.Button(self, id=wx.ID_ANY,
                                  label=label,
                                  size=self.gui.submit_button_size)

        self.box_sizer.Add(submit_button, 0)

        submit_button.Bind(wx.EVT_BUTTON, self.on_welcome_submit)
        submit_button.Show()
        self.gui.elements_in_sizer.append(submit_button)

    def on_welcome_submit(self, event):
        """Go to next page when user presses submit button."""
        self.gui.remove_elements_from_sizer()
        self.Hide()
        self.gui.survey_stage()


class ListenerButtonsPanel(wx.Panel):
    """Panel for displaying two pictures."""

    def __init__(self, parent):
        """Initialise images etc."""
        wx.Panel.__init__(self, parent)
        self.gui = parent



        self.speaker_coords = self.gui.speaker_coords
        Glbls.grid_size = 12

        self.box_sizer = wx.BoxSizer(wx.VERTICAL)
        # Issue here
        Glbls.grid_sizer = wx.FlexGridSizer(6,2,5,5)

        self.add_grid()

        # Replace this with referent buttons
        images = [self.gui.image_buttons_1, self.gui.image_buttons_2]
        images = random.sample(images,len(images))
        # self.gui.image_buttons_1 = images[0]
        # self.gui.image_buttons_2 = images[1]
        # self.add_images(self.gui.image_buttons_1, self.gui.image_buttons_2)
        self.add_radio_box()
        self.box_sizer.Add(Glbls.grid_sizer, 0)
        self.add_submit_button("OK")

        self.SetSizer(self.box_sizer)
        self.box_sizer.Fit(self)
        self.box_sizer.Layout()
        self.Center()


    def add_grid(self):
        grid_coords = []
        # print(self.speaker_coords,"speaker_coords")
        for i, value in enumerate(self.speaker_coords):
            if value == 1:
                grid_coords.append([int(i/Glbls.grid_size), i%Glbls.grid_size])

        self.message_sizer = wx.BoxSizer(wx.HORIZONTAL)
        self.grid = wx.grid.Grid(self, -1, style=wx.BORDER_SIMPLE)
        self.grid_list = []
        #self.box_sizer.Add(self.grid,0)
        self.grid.CreateGrid(self.gui.GridWidth, self.gui.GridHeight)
        self.grid.SetDefaultRowSize(40)
        self.grid.SetDefaultColSize(40)
        self.grid.SetRowLabelSize(0)
        self.grid.SetColLabelSize(0)
        self.grid.SetCellHighlightROPenWidth(0)
        self.grid.ShowScrollbars(wx.SHOW_SB_NEVER,wx.SHOW_SB_NEVER)
        #self.grid.AutoSize() # <--This may have to change

        for m in range(0,self.gui.GridWidth):
            self.grid_list.append([])
            for n in range(0,self.gui.GridHeight):
                self.grid_list[m].append([])
                self.grid.SetReadOnly(m,n)
                self.grid.SetCellValue(m,n,str(""))
                if [m,n] in grid_coords:
                    self.grid.SetCellBackgroundColour(m, n, wx.BLACK)

        self.message_sizer.Add(wx.StaticText(self, label = "Time to guess!  Your partner has sent you the following grid image:  "), 0)
        self.message_sizer.Add(self.grid, 0)
        self.box_sizer.Add(self.message_sizer, 0)

    # Not used anymore
    def add_images(self, pic_1, pic_2):
        """Add image to frame."""
        # the image file is transmitted via message from
        # server to client

        #image_sizer = wx.BoxSizer(wx.HORIZONTAL)
        image_path_1 = os.path.join(self.gui.image_path, pic_1)
        image_path_2 = os.path.join(self.gui.image_path,pic_2)

        im_1 = wx.Image(image_path_1)
        im_2 = wx.Image(image_path_2)

        dimensions_1 = self.gui.adjust_dimensions(im_1)
        im_1.Rescale(dimensions_1[0], dimensions_1[1])

        dimensions_2 = self.gui.adjust_dimensions(im_2)
        im_2.Rescale(dimensions_2[0], dimensions_2[1])

        bmap_1 = wx.Bitmap(im_1)
        bmap_2 = wx.Bitmap(im_2)

        image_1 = wx.StaticBitmap(self, wx.ID_ANY, bmap_1)
        image_2 = wx.StaticBitmap(self, wx.ID_ANY, bmap_2)


    def add_radio_box(self):
        """Add radio buttons for referent selection."""
        #buttons_sizer = wx.BoxSizer(wx.HORIZONTAL)

        # Set correct referent and make sure it shows up.

        self.Bind(wx.EVT_RADIOBUTTON, self.onRadioClick)

        # Change the labels to select 8/12 referents for the radio buttons. The correct option should always be present.
        # Store the correct referent.
        # Out of the list of 11 others, make a list of 7 randomly chosen referents. Append the correct referent.
        # Randomly choose a number 1-8 to store the referents in. We can use random.shuffle() but this shuffles in place
        # We basically should have tuples (a,b) where a = the referent list index, b = the radio button.

        # The hierarchies idea needs to be discussed. This might be challenging to implement
        # if we need to group referents and shuffle within that group.

        # Two types of trials
        # 1) freely select a subset of 8/11
        # 2) a group of referents that we definitely want to have w/ the rest populated by random ones.
        # If we want to have the substitution for every referent, we will need a sublist of definites for each referent
        # For now, have one competitor for each.


        # for ref in list_of_referents:
        #     create radiobuttons with the label
        self.radioButtonList = []


        for i in range(len(self.gui.referent_list)):
            self.radioButtonList.append(wx.RadioButton(self, wx.ID_ANY, label=self.gui.referent_list[i],style=wx.RB_GROUP))
            self.radioButtonList[i].SetFont(wx.Font(10.0, wx.DEFAULT, wx.NORMAL,wx.NORMAL))

        print("referent_list in radio_box", self.gui.referent_list)
        # print("labels in radioButtonList") #figure out a way
        print("size of radioButtonList", len(self.radioButtonList))

        labelList = []
        for i in range(len(self.radioButtonList)):
            print("in GetLabel loop",i)
            print("getLabel", self.radioButtonList[i].GetLabel())
            labelList.append(self.radioButtonList[i].GetLabel())

        print("labels of elements in radioButtonList", labelList)

        # OLD CODE
        # self.radio_1 = wx.RadioButton(self, wx.ID_ANY, label="Dog",
        #                               style=wx.RB_GROUP)
        # self.radio_1.SetFont(wx.Font(10.0, wx.DEFAULT, wx.NORMAL,
        #                              wx.NORMAL))


        #buttons_sizer.Add(self.radio_a, 0)
        #buttons_sizer.Add(self.radio_b, 0)

        for i in self.radioButtonList:
            Glbls.grid_sizer.Add(i, 0)

        self.gui.elements_in_sizer.extend(self.radioButtonList)

    def onRadioClick(self,e):
        thisrb = e.GetEventObject()
        for rb in self.radioButtonList:
            if rb != thisrb:
                rb.SetValue(False)
        self.gui.currentGuess = thisrb.GetLabel()
        print(thisrb.GetLabel(), ' is clicked from Radio Group')

    def add_submit_button(self, label):
        """Add a submit button. Its position is set.

        :param label: the text written on the button.
        :type label: str.
        """
        submit_button = wx.Button(self, id=wx.ID_ANY,
                                  label=label,
                                  size=self.gui.submit_button_size)
        self.box_sizer.Add(submit_button, 0)
        # when the participant clicks on the button, the on_submit()
        # method is called
        submit_button.Bind(wx.EVT_BUTTON, self.on_referent_guess)
        submit_button.Show()
        self.gui.elements_in_sizer.append(submit_button)

    def on_referent_guess(self, event):
        # print("on picture choice string", event.GetString())
        # print("on picture choice client data", event.GetClientData())
        # print("on picture choice selection", event.GetSelection())
        """Get the values of the radio boxes."""
        self.gui.submitted_message = {"msg": "listener pic chosen"}

        for i in self.radioButtonList:
            if i.GetValue():
                self.gui.listener_chosen_pic = self.gui.currentGuess

                print("radioButton val", self.gui.listener_chosen_pic)
                self.Hide()
                self.gui.submit_message()

                return
        self.gui.submitted_message = {"msg":"listener still choosing"} #now redundant


# WHAT IS THIS FOR?
class SpeakerButtonsPanel(wx.Panel):
    """Panel for displaying two pictures."""

    def __init__(self, parent):
        """Initialise images etc."""
        wx.Panel.__init__(self, parent)
        self.gui = parent

        self.box_sizer = wx.BoxSizer(wx.VERTICAL)
        Glbls.grid_sizer = wx.FlexGridSizer(2,2)

        self.add_images(self.gui.image_buttons_1, self.gui.image_buttons_2)
        self.add_radio_box()
        self.box_sizer.Add(Glbls.grid_sizer, 0)
        self.add_submit_button("OK")

        self.SetSizer(self.box_sizer)
        self.box_sizer.Fit(self)
        self.box_sizer.Layout()
        self.Center()

    def add_submit_button(self, label):
        """Add a submit button. Its position is set.

        :param label: the text written on the button.
        :type label: str.
        """
        submit_button = wx.Button(self, id=wx.ID_ANY,
                                  label=label,
                                  size=self.gui.submit_button_size)
        self.box_sizer.Add(submit_button, 0)
        # when the participant clicks on the button, the on_submit()
        # method is called
        submit_button.Bind(wx.EVT_BUTTON, self.on_picture_choice)
        submit_button.Show()
        self.gui.elements_in_sizer.append(submit_button)

    # def on_picture_choice(self, event):
    #     """Get the values of the radio boxes."""
    #     # print("on picture choice", event)
    #     self.gui.submitted_message = "pic chosen"
    #     if self.radio_a.GetValue():
    #         self.gui.chosen_pic = self.gui.image_buttons_1
    #         self.gui.alt_pic = self.gui.image_buttons_2
    #         self.gui.submit_message()
    #     elif self.radio_b.GetValue():
    #         self.gui.chosen_pic = self.gui.image_buttons_2
    #         self.gui.alt_pic = self.gui.image_buttons_1
    #         self.gui.submit_message()
    #     else:
    #         self.gui.submitted_message = "still choosing" #now redundant
    #     self.Hide()


# class SpeakerReferentsListPanel(wx.Panel):


#     def __init__(self, parent):
#         """Initialise panel with welcome message."""
#         wx.Panel.__init__(self, parent)
#         self.gui = parent
#         self.box_sizer = wx.BoxSizer(wx.VERTICAL)


#         reflist = '\n'.join(str(ref) for ref in self.gui.referent_list)

#         self.text = wx.StaticText(self, wx.ID_ANY, label=reflist)
#         self.text.SetFont(wx.Font(10.0, wx.DEFAULT, wx.NORMAL,wx.NORMAL))


#         # self.box_sizer.Add(text, 0)

#         self.SetSizer(self.box_sizer)
#         # self.box_sizer.Fit(self)
#         self.box_sizer.Layout()
#         self.Center()




class FeedbackPage(wx.Panel):


    def __init__(self, parent,sent_coords):
        wx.Panel.__init__(self, parent)
        self.gui = parent


        self.ver_box_sizer = wx.BoxSizer(wx.VERTICAL)
        self.hor_box_sizer = wx.BoxSizer(wx.HORIZONTAL)     
        self.SetSizer(self.hor_box_sizer)  
        self.hor_box_sizer.Fit(self)
        self.hor_box_sizer.Layout()
        self.Center()




        self.CreateFeedbackGrid(sent_coords)

        
    def OnMotion(self, event):
        pass

    def CreateFeedbackGrid(self,sent_coords):
        self.sent_coords = sent_coords
        self.grid_coords = []
        self.grid_list = []
        # print(self.speaker_coords,"speaker_coords")
        for i, value in enumerate(self.sent_coords):
            if value == 1:
                self.grid_coords.append([int(i/Glbls.grid_size), i%Glbls.grid_size])





        print("Creating feedback grid...")
        # if (self.drawnFeedbackGrid == True):
        #     print("Feedback grid drawn at least once")
        #     pass
        # else:

        self.grid = wx.grid.Grid(self, -1, style=wx.BORDER_SIMPLE)

        self.grid.CreateGrid(self.gui.GridWidth, self.gui.GridHeight)
        self.grid.SetDefaultColSize(int(Glbls.GridColSize / 1.5))
        self.grid.SetDefaultRowSize(int(Glbls.GridRowSize / 1.5))
        self.grid.SetRowLabelSize(0)
        self.grid.SetColLabelSize(0)
        self.grid.SetCellHighlightROPenWidth(0)
        self.grid.ShowScrollbars(wx.SHOW_SB_NEVER, wx.SHOW_SB_NEVER)
        self.grid.GetGridWindow().Bind(wx.EVT_MOTION, self.OnMotion)  # prevent drag selection

        for m in range(0,self.gui.GridWidth):
            self.grid_list.append([])
            for n in range(0,self.gui.GridHeight):
                self.grid_list[m].append([])
                self.grid.SetReadOnly(m,n)
                self.grid.SetCellValue(m,n,str(""))
                if [m,n] in self.grid_coords:
                    self.grid.SetCellBackgroundColour(m, n, wx.BLACK)

        self.hor_box_sizer.Add(self.grid, 0)
        self.hor_box_sizer.Fit(self)
        # self.ver_box_sizer.Add(self.hor_box_sizer,0)
        # self.SetSizer(self.ver_box_sizer)
        self.ver_box_sizer.Fit(self)




        #Fills in cells  
        #and sets all cells in grid to ReadOnly.

        self.grid.Refresh()







class DrawingPage(wx.Panel):
    """Panel for grid drawing."""
    drawLock = threading.Lock()

    def __init__(self, parent):
        """Initialise the grid."""




        wx.Panel.__init__(self, parent)
        self.gui = parent
        self.remaining = math.ceil(Glbls.roundLength)

        if Glbls.display_all_referents_to_speaker == True:
            # print("Show referents to speaker true")
     
            reflist = '\n'.join(str(ref) for ref in self.gui.referent_list)
        else:
            # print("Show referents to speaker False")
            reflist = ""
        self.ref_list_text = wx.StaticText(self, wx.ID_ANY, label=reflist)
        self.ref_list_text.SetFont(wx.Font(18.0, wx.DEFAULT, wx.NORMAL,wx.NORMAL))
        self.dummy_text1 = wx.StaticText(self, label="")
        if Glbls.timeRounds == True and Glbls.displayTimer == True:
            self.timer_display = wx.StaticText(self, label="\nYou have %s seconds from your first click!" % str(self.remaining))
            self.timer_display.SetFont(wx.Font(16.0, wx.DEFAULT, wx.NORMAL,wx.NORMAL))

        self.clicked = False
        self.CanClick = True
        # self.drawnFeedbackGrid = False

        self.ver_box_sizer = wx.BoxSizer(wx.VERTICAL)
        self.hor_box_sizer = wx.BoxSizer(wx.HORIZONTAL)
        self.left_ver_box_sizer = wx.BoxSizer(wx.VERTICAL)
        self.left_hor_box_sizer = wx.BoxSizer(wx.HORIZONTAL)

        # self.SetSizer(self.ver_box_sizer)
        # self.ver_box_sizer.Fit(self)
        # self.ver_box_sizer.Layout()
        # self.Center()
        self.SetSizer(self.hor_box_sizer)
        self.hor_box_sizer.Fit(self)
        self.hor_box_sizer.Layout()
        self.Center()

        

        # Initialize vector of filled values to transmit
        self.fill_vector = [0]*self.gui.GridWidth*self.gui.GridHeight

        # Choose a random referent in the list received from Server as the "choice" referent.
        # self.referent_list_length = len(self.gui.referent_list)
        # self.referent_index = random.randint(0, self.referent_list_length - 1)
        self.gui.referent_string = random.choice(self.gui.referent_list)
        #This should really happen on the Server side!

        self.referent_display_text = "To communicate: " + self.gui.referent_string + "\n" + " "
        self.referent_display = wx.StaticText(self, label = self.referent_display_text)
        self.referent_display.SetFont(wx.Font(20.0, wx.DEFAULT, wx.NORMAL,wx.NORMAL))
        # print("set gui referent string to:", self.gui.referent_string)


        self.grid = wx.grid.Grid(self, -1, style=wx.BORDER_SIMPLE)
        # self.ver_box_sizer.Add(self.timer_display,0)
        self.ver_box_sizer.Add(self.referent_display, 0)
        # self.hor_box_sizer.Add(self.grid, 0)
        self.ver_box_sizer.Add(self.grid, 0)
        if Glbls.timeRounds == True and Glbls.displayTimer == True:
            self.ver_box_sizer.Add(self.timer_display, 0)
        # self.hor_box_sizer.Add(self.image_1,0)
        # # self.hor_box_sizer.Add(self.image_2,0)
        self.left_ver_box_sizer.Add(self.dummy_text1,1)
        self.left_ver_box_sizer.Add(self.ref_list_text,1)
        # self.left_hor_box_sizer.Add(self.left_ver_box_sizer,1)
        # self.hor_box_sizer.Add(self.ref_list_text,0)
        self.hor_box_sizer.Add(self.left_ver_box_sizer,1)
        self.hor_box_sizer.Add(self.ver_box_sizer, 1)
        
        # Glbls.GridRowSize = 40
        # Glbls.GridColSize = 40

        # Create the timer
        self.timer = wx.Timer(self)
        self.Bind(wx.EVT_TIMER, self.update, self.timer)

        # Add submit button
        self.add_submit_button("Send")

        # Then we call CreateGrid to set the dimensions of the grid
        self.grid.CreateGrid(self.gui.GridWidth, self.gui.GridHeight)
        self.grid.SetDefaultColSize(Glbls.GridRowSize)
        self.grid.SetDefaultRowSize(Glbls.GridColSize)
        self.grid.SetRowLabelSize(0)
        self.grid.SetColLabelSize(0)
        self.grid.SetCellHighlightROPenWidth(0)
        self.grid.ShowScrollbars(wx.SHOW_SB_NEVER, wx.SHOW_SB_NEVER)
        # self.grid.AutoSize() # <--This may have to change

        self.grid_list = []

        # Make all cells read-only
        for m in range(0, self.gui.GridWidth):
            self.grid_list.append([])
            for n in range(0, self.gui.GridHeight):
                self.grid_list[m].append(0)
                self.grid.SetReadOnly(m, n)
                # self.grid.SetCellTextColour(m, n, "white")
                # self.grid.SetCellValue(m,n,str(0))

        # Bind clicking events
        self.Bind(wx.grid.EVT_GRID_CELL_LEFT_CLICK, self.OnClick)
        # self.Bind(wx.grid.EVT_GRID_CELL_LEFT_DCLICK, self.OnDClick)
        # self.Bind(wx.grid.EVT_GRID_RANGE_SELECT, self.OnDragSelect)

        self.grid.GetGridWindow().Bind(wx.EVT_MOTION, self.OnMotion)  # prevent drag selection
        # self.grid.GetGridWindow().Bind(wx.EVT_SCROLLWIN, self.OnScroll) #prevent drag selection

        # Clicks parameter
        self.ClickThreshold = 1

        # self.Show()

    def OnMotion(self, event):
        pass

    # def OnScroll(self,event):
    #     print("scroll")
    #     event.Skip()

    # def OnDragSelect(self,event):
    #     # DrawingPage.drawLock.acquire()
    #     # print("OnDragSelect")
    #     self.grid.ClearSelection()
    #     # DrawingPage.drawLock.release()

    def CreateFeedbackGrid(self):
        pass
        # print("Creating feedback grid...")
        # if (self.drawnFeedbackGrid == True):
        #     print("Feedback grid drawn at least once")
        #     pass
        # else:
        #     self.drawnFeedbackGrid == True
        #     print("Feedback grid drawn first time")
        #     self.grid = wx.grid.Grid(self, -1, style=wx.BORDER_SIMPLE)

        #     self.grid.CreateGrid(self.gui.GridWidth, self.gui.GridHeight)
        #     self.grid.SetDefaultColSize(int(Glbls.GridColSize / 1.5))
        #     self.grid.SetDefaultRowSize(int(Glbls.GridRowSize / 1.5))
        #     self.grid.SetRowLabelSize(0)
        #     self.grid.SetColLabelSize(0)
        #     self.grid.SetCellHighlightROPenWidth(0)
        #     self.grid.ShowScrollbars(wx.SHOW_SB_NEVER, wx.SHOW_SB_NEVER)

        #     self.grid.GetGridWindow().Bind(wx.EVT_MOTION, self.OnMotion)  # prevent drag selection

        #     self.hor_box_sizer.Add(self.grid, 0)
        #     self.hor_box_sizer.Fit(self)
        #     # self.ver_box_sizer.Add(self.hor_box_sizer,0)
        #     # self.SetSizer(self.ver_box_sizer)
        #     self.ver_box_sizer.Fit(self)

        #     # Sets all cells in grid to ReadOnly.
        #     for m in range(0, self.gui.GridWidth):
        #         for n in range(0, self.gui.GridHeight):
        #             self.grid.SetReadOnly(m, n)
        #             value = self.grid_list[m][n]
        #             if int(value) % 2 != 0:
        #                 self.grid.SetCellTextColour(m, n, wx.Colour("black"))
        #                 self.grid.SetCellBackgroundColour(m, n, wx.Colour("black"))
        #     self.grid.Refresh()

    def OnClick(self, event):
        DrawingPage.drawLock.acquire()
        # print("OnClick")
        if self.clicked == False and self.CanClick == True:
            self.StartTimer()
            self.timer_display.SetLabel("%s seconds left!" % str(self.remaining))
            self.clicked = True
            # self.gui.srvsock.send(self.gui.encode_msg("6666FIRSTCLICK6666"))
            # self.StartTimer()
            # self.timer_display.SetLabel("%s seconds left!" % str(self.remaining))
        if self.CanClick == True:
            CellCoords = [event.GetRow(), event.GetCol()]
            # print("CellCoords",CellCoords)
            CellValue = self.grid_list[CellCoords[0]][CellCoords[1]]
            # CellValue = self.grid.GetCellValue(*CellCoords)
            # self.grid.SetCellTextColour(CellCoords[0],CellCoords[1], "white") #Quick hack to stop bug where numbers sometimes visible
            # self.grid.SetCellValue(CellCoords[0],CellCoords[1],str(int(CellValue)+1))
            self.grid_list[CellCoords[0]][CellCoords[1]] += 1
            self.CheckValue(CellCoords)
            # print("Just checked value for OnClick")
        else:
            pass
        DrawingPage.drawLock.release()

    # #
    # def OnDClick(self, event):
    #     DrawingPage.drawLock.acquire()
    #     # print("double clicking")
    #     # print "OnDClick: ", self.grid_list
    #     if self.CanClick == True:
    #         CellCoords = [event.GetRow(), event.GetCol()]
    #         CellValue = self.grid_list[CellCoords[0]][CellCoords[1]]
    #         self.grid.SetCellTextColour(CellCoords[0], CellCoords[1],
    #                                     "white")  # Quick hack to stop bug where numbers sometimes visible
    #         # self.grid.SetCellValue(CellCoords[0],CellCoords[1],str(int(CellValue)+1))
    #         self.grid_list[CellCoords[0]][CellCoords[1]] += 1
    #         self.CheckValue(CellCoords)
    #     else:
    #         pass
    #     DrawingPage.drawLock.release()

    def CheckValue(self, coords):

        # print("coords",coords)
        # tell the server there's been a click
        # self.gui.srvsock.send(self.gui.encode_msg("6666"+ str(tuple(coords)) +"6666"))
        # set the cell color to black if there's been enough clicks
        # CellValue = self.grid.GetCellValue(*coords)

        CellValue = self.grid_list[coords[0]][coords[1]]
        # print("just got CellValue")
        if int(CellValue) >= self.ClickThreshold:
            # print("over threshold")
            CellValue = self.grid_list[coords[0]][coords[1]]
            # print("got Cellvalue again")
            self.grid.SetCellValue(coords[0], coords[1], "")
            if self.gui.AllowErase == True and int(CellValue) % 2 == 0:
                self.grid.SetCellTextColour(coords[0], coords[1], wx.Colour("white"))
                self.grid.SetCellBackgroundColour(coords[0], coords[1], wx.Colour("white"))
                self.fill_vector[(coords[0]*self.gui.GridWidth)+coords[1]] = 0

            else:
                self.grid.SetCellTextColour(coords[0], coords[1], wx.Colour("black"))
                self.grid.SetCellBackgroundColour(coords[0], coords[1], wx.Colour("black"))
                self.fill_vector[(coords[0]*self.gui.GridWidth)+coords[1]] = 1
            # print(self.fill_vector)
            #flip value of cell
          

            # print(self.fill_vector)
            self.grid.Refresh()
        # print("just refreshed")

    def StartTimer(self):
        self.timer.Start(1000)

    def update(self, event):
        self.remaining -= 1
        if self.remaining < 1:
            self.submitGrid()
            # self.timer.Stop()
        else:
            self.timer_display.SetLabel("%s seconds left!" % str(self.remaining))

    def add_submit_button(self, label):
        """Add a submit button. Its position is set.

        :param label: the text written on the button.
        :type label: str.
        """
        submit_button = wx.Button(self, id=wx.ID_ANY,
                                  label=label,
                                  size=self.gui.submit_button_size)
        self.ver_box_sizer.Add(submit_button, 0)
        # when the participant clicks on the button, the on_submit()
        # method is called
        submit_button.Bind(wx.EVT_BUTTON, self.OnSubmit)
        submit_button.Show()
        self.gui.elements_in_sizer.append(submit_button)

    def submitGrid(self):
        self.CanClick = False
        # self.drawnFeedbackGrid = False
        # self.CreateFeedbackGrid()
        self.gui.submitted_message = {"msg":"coords","coords":self.fill_vector}
        self.gui.submit_message()



    def OnSubmit(self, event):
        self.submitGrid()

    def close_up(self):
        """Close everything."""
        # self.srvsock.close()
        msg = "closing client"
        pub.sendMessage("clientclosed", data=msg)
        self.Destroy()
        sys.exit()

        # comment this section out if you don't want run_client to remember
        # the ip next time
        # try:
        # os.remove('temp_ip')
        # except(WindowsError):
        # pass

    def on_exit_app(self, event):
        """A dummy function that runs if user tries to close the gui."""
        pass


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
MESSAGES PAGE
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""


class MessagePanel(wx.Panel):
    """Panel for messages to the participant."""

    def __init__(self, parent, msg, label=None):
        """Display a message to the participant."""
        wx.Panel.__init__(self, parent)
        self.box_sizer = wx.BoxSizer(wx.VERTICAL)
        self.gui = parent

        message = wx.StaticText(self, label=msg)
        message.SetFont(wx.Font(14, wx.DEFAULT, wx.NORMAL,
                                wx.BOLD))
        message.Show()
        self.box_sizer.Add(message, 0)
        self.gui.elements_in_sizer.append(message)

        if label == "OK":
            self.add_submit_button(label)
        if label == "close":
            self.add_close_button("Close")

        self.SetSizer(self.box_sizer)
        self.box_sizer.Fit(self)
        self.box_sizer.Layout()
        self.Center()

    def add_submit_button(self, label):
        """Add a submit button. Its position is set.

        :param label: the text written on the button.
        :type label: str.
        """
        submit_button = wx.Button(self, id=wx.ID_ANY,
                                  label=label,
                                  size=self.gui.submit_button_size)
        self.box_sizer.Add(submit_button)
        # when the participant clicks on the button, the on_submit()
        # method is called
        submit_button.Bind(wx.EVT_BUTTON, self.gui.on_submit)
        submit_button.Show()
        self.gui.elements_in_sizer.append(submit_button)

    def add_close_button(self, label):
        """Add the button for closing everything."""
        submit_button = wx.Button(self, id=wx.ID_ANY,
                                  label=label,
                                  size=self.gui.submit_button_size)
        self.box_sizer.Add(submit_button)
        # when the participant clicks on the button, the on_submit()
        # method is called
        submit_button.Bind(wx.EVT_BUTTON, self.gui.on_submit)
        submit_button.Show()
        self.gui.elements_in_sizer.append(submit_button)


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
INSTRUCTIONS PAGE
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""


class InstructionsPage(wx.Panel):
    """Panel for the instructions page."""

    def __init__(self, parent):
        """Display instructions."""
        wx.Panel.__init__(self, parent)
        self.box_sizer = wx.BoxSizer(wx.VERTICAL)

        self.gui = parent

        message = """\nPlease read the instructions carefully.\n
Do not hesitate to ask the researcher any questions you have.\n"""
        instruct = wx.StaticText(self, label=message)

        instruct.SetFont(wx.Font(14, wx.DEFAULT, wx.NORMAL,
                                 wx.BOLD))
        instruct.Show()

        with codecs.open(self.gui.instructions_file, "r", "utf-8") as read_handle:
            instructions = read_handle.read()

        # Insert parameters into speaker instructions
        # print("click threshold", self.gui.ClickThreshold)
        # if "%s" in instructions:
        #     instructions = instructions % (self.gui.ClickThreshold,self.gui.SecondsGiven)

        instruction_display = rt.RichTextCtrl(self, id=wx.ID_ANY,
                                              style=wx.TE_READONLY,
                                              size=(400, 350))
        instruction_display.BeginBold()
        instruction_display.WriteText("Instructions")
        instruction_display.WriteText("\n\n\n")
        instruction_display.EndBold()
        instruction_display.WriteText(instructions)
        instruction_display.SetFont(wx.Font(14, wx.DEFAULT, wx.NORMAL,
                                    wx.NORMAL))
        instruction_display.Show()

        dummy_1 = wx.StaticText(self, label="")
        dummy_1.Show()

        self.box_sizer.Add(instruct, 0)
        self.box_sizer.Add(instruction_display, 0)
        self.box_sizer.Add(dummy_1, 0)

        self.gui.elements_in_sizer.append(instruct)
        self.gui.elements_in_sizer.append(instruction_display)
        self.gui.elements_in_sizer.append(dummy_1)

        self.add_submit_button("OK")

        self.SetSizer(self.box_sizer)
        self.box_sizer.Fit(self)
        self.box_sizer.Layout()
        self.Center()

    def add_submit_button(self, label):
        """Add a submit button. Its position is set.

        :param label: the text written on the button.
        :type label: str.
        """
        submit_button = wx.Button(self, id=wx.ID_ANY, label=label,
                                  size=self.gui.submit_button_size)
        self.box_sizer.Add(submit_button, 0)
        # when the participant clicks on the button, the on_submit()
        # method is called
        submit_button.Bind(wx.EVT_BUTTON, self.on_instructions_submit)
        submit_button.Show()
        self.gui.elements_in_sizer.append(submit_button)

    def on_instructions_submit(self, event):
        """Submit message that the instructions were read."""
        self.Hide()
        self.gui.submit_message()


# Listens for incoming data
class Reader(threading.Thread):
    """Class for reading messages from the server."""

    indata = ''
    ilock = threading.Lock()

    def __init__(self, srvsock, gui):
        """Initialise the messages reader."""
        self.gui = gui
        self.srvsock = srvsock
        threading.Thread.__init__(self)
        self.buffer = []

    def decode_strings(self, string):
        """Decode a string to utf-8."""
        return(string.decode("utf-8"))

    def recv_end(self, the_socket):
        """Get messages from the server."""
        end = Glbls.server_end_marker
        total_data = self.buffer
        messages = []
        data = ''
        raw_data = ""
        while True:
            raw_data = the_socket.recv(self.gui.bufsize)
            # print "rawdata = ", raw_data
            data = self.decode_strings(raw_data)
            # print "data = ", data
            if end in data:
                total_data.append(data[:data.find(end)])
                messages.append(total_data)
                total_data = []
                self.buffer = []
                mesg_len = len(end) + len(data[:data.find(end)])
                if mesg_len < len(data):
                    leftover = data[mesg_len:]
                    while True:
                        if end in leftover:
                            total_data.append(leftover[:leftover.find(end)])
                            messages.append(total_data)
                            total_data = []
                            msg_len = (len(end) +
                                       len(leftover[:leftover.find(end)]))
                            if len(leftover) == msg_len:
                                break
                            else:
                                leftover = leftover[msg_len:]
                        else:
                            self.buffer.append(leftover)
                            break

                break
            total_data.append(data)
            if len(total_data) > 1:
                # check if end_of_data was split
                last_pair = total_data[-2] + total_data[-1]
                if end in last_pair:
                    total_data[-2] = last_pair[:last_pair.find(end)]
                    total_data.pop()
                    break
        messages2return = []
        for msg in messages:
            messages2return.append(''.join(msg))


        return(messages2return)

    def run(self):
        """Read incoming data and check if it is from the server."""
        while 1:
            try:
                ind = self.recv_end(self.srvsock)
            except:
                print('Connection closed. No longer receiving data.')
                break
            Reader.ilock.acquire()
            for Reader.indata in ind:
                if Reader.indata != "":
                    try:
                        Reader.ilock.release()
                    except:
                        pass
                    # go to incoming_message() for deciding which stage is
                    # the next
                    wx.CallAfter(self.gui.incoming_message, Reader.indata)
                else:
                    Reader.ilock.release()


class DummyPanel(wx.Panel):
    """Dummy panel for getting elements in the middle of the page."""

    def __init__(self, parent):
        """Initialise panel with welcome message."""
        wx.Panel.__init__(self, parent)
        self.gui = parent
        self.box_sizer = wx.BoxSizer(wx.VERTICAL)

        # text = wx.StaticText(self, wx.ID_ANY, label="TEST")
        # self.box_sizer.Add(text, 0)

        self.SetSizer(self.box_sizer)
        # self.box_sizer.Fit(self)
        self.box_sizer.Layout()
        self.Center()





class Client:
    """The client framework."""

    def __init__(self, parent, host, name):
        """Initialise the GUI for each client."""
        # The "False" parameter means "don't redirect stdout and stderr
        # to a gui" (direct it to the terminal instead)
        app = wx.App(False)
        # initialize GuiWindow class
        frame = GuiWindow(parent, wx.ID_ANY, '', host, name)

        # move the Gui window to the specified position
        # frame.SetPosition((500, 100))
        app.MainLoop()


# Client(None,"localhost","yourname")
# This can be used to bootstrap the Client without using run_client.py
