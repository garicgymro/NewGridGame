from __future__ import division
from __future__ import unicode_literals

import codecs
import json
# import os
# import random
import re
import socket
import sys
import threading
import random
import os
import pickle

# Import WXPython
try:
    import wx
except ImportError:
    raise ImportError("The wxPython module is required to run this program")

# from pubsub import pub
import wx.richtext as rt

# should be redundant
import wx.grid
import wx.lib.colourdb


# Creates window where player will interact
# Why does GuiWindow take a wx.Frame object as a parameter?
# What are the pic fields for?

# Contains two methods
# 1) remove_elements_from_sizer(self)
# 2) speaker_draw_stage(self)
# Fields are grouped into
# 1) Window properties (window height/width, image_buttons_1/2, AllowErase)
# 2) Game tracking (participant_no, listener_no, practice_over, round_counter/info, score, role)
# 3) Game setup (main_sizer, elements_in_sizer,image_height/width/path, instructions_file)
# 4) Picture info (alt/chosen_pic, listener_chosen_pic, pic_for_displaying)
# 5) After-game survey (submit_button_size, submitted_message, survey_answers)
#

class GuiWindow(wx.Frame):
    """Construct the window(s) the participants of the experiment see."""

    # Constructor
    def __init__(self, parent, id, title, host, name):
        """Initialise the GUI window for the participant.

        # :param parent   :the parent of this window
        # :type parent    :wx python object
        # :param id       :id of the frame, assigned automatically
        # :type id        :int
        # :param title    :name of the current window
        # :type title     :str
        # :param host     :name of the host
        # :type host      :str
        # :param name     :the participant's name
        # :type name      :str
        # """
        # self.bufsize = 4096
        # self.host = host
        # self.port = 5000

        # """INITIALISING GLOBAL VARIABLES"""
        # # name of the participant
        # self.name = name
        # # set self.ready to 1 by first message from server
        # # (means all clients are connected)
        # self.ready = 0
        # # set stage and role of players
        # self.stage = "pregame"
        # self.role = "undecided"
        # set image size
        # self.image_width = 200
        # self.image_height = 200

        # A sizer is a subwindow -> used to organize the grid/buttons in the space

        self.image_width = 250
        self.image_height = 250
        # server_end_marker must be the same as in the Server script
        # self.server_end_marker = "!!!%%%&&&!!!"
        # all elements of all sizers are collected in this list
        self.elements_in_sizer = []

        # path to instructions file given by a server message
        self.instructions_file = ""
        # the image file(s)
        self.image_buttons_1 = ""
        self.image_buttons_2 = ""
        self.chosen_pic = ""
        self.alt_pic = ""
        self.listener_chosen_pic = ""
        self.pic_for_displaying = ""
        # score
        self.score = 0
        self.round_counter = 0
        # path to the image directory
        self.image_path = "images"
        # collect all sizer elements for clearing them in one
        # speaker and listener number for getting the right pairs
        self.speaker_no = ""
        self.listener_no = ""
        # during the practice rounds, each client only has a
        # participant number without a role
        self.participant_no = ""
        # answers of the survey
        self.survey_answers = ""
        # size of the submit buttons
        self.submit_button_size = (500, -1)
        # the sentences generated by the speaker are added to this list
        # the message decides which state or stage is taken
        self.submitted_message = ""
        self.round_info = ""
        self.practice_over = False
        self.AllowErase = True
        self.GridWidth = 12
        self.GridHeight = 12

        # What are these?
        # """SERVER MESSAGES"""
        # # identifies special messages from the Server
        # self.srvr_msg = re.compile(r'9999.*9999(?!\s)')
        # self.kill_msg = re.compile(r".*KILL.*")
        # # transfers start of all clients, path to images and client number
        # self.begin_msg = re.compile(r'9999BEGIN(.*)@(.*)@(.*)@(.*)@(.*)9999(?!\s)')
        # # tranfers message from listener: listener number and round info
        # self.listener_msg = re.compile(r'9999LISTENER(.*)_(.*)9999(?!\s)')
        # self.listener_buttons_msg = re.compile(r"9999BUTTONS_LISTENER(.*)@(.*)@(.*)9999")
        # # identifies message from speaker: current image, speaker number
        # # and round info
        # self.speaker_buttons_msg = re.compile(r"9999BUTTONS_SPEAKER(.*)@(.*)@(.*)9999")
        # # a message that is directed to all participants
        # self.msg_for_all = re.compile(r"9999ALL(.*)@(.*)9999(?!\s)")
        # # message that identifies the beginning of the experiment
        # # (welcome page)
        # self.welcome_msg = re.compile(r"9999WELCOME(.*)9999(?!\s)")
        # # message for listener: the chosen picture
        # self.pic_from_speaker = re.compile(r"9999PIC(.*)9999(?!\s)")
        # # listener response: the guessed picture
        # self.pic_from_listener = re.compile(r"9999GUESS(.*)9999(?!\s)")
        # # coordinates
        # self.coords_from_speaker = re.compile(r"9999COORD(.*)9999(?!\s)")

        # initialise the gui
        no_resize = wx.DEFAULT_FRAME_STYLE & ~ (wx.RESIZE_BORDER |
                                                wx.MAXIMIZE_BOX)
        # wx.RESIZE_BOX |

        # Instantiate a frame - why is this done within GuiWindow class? Play with it
        # What is main_sizer and elements_in_sizer?
        wx.Frame.__init__(self, parent, id, title="Communication Experiment",
                          size=(1600, 800))
        # create the main sizer
        self.main_sizer = wx.BoxSizer(wx.VERTICAL)
        # self.Show()
        self.SetSizer(self.main_sizer)
        self.Layout()
        self.SetBackgroundColour("WHITE")

        self.remove_elements_from_sizer()  # What's this do?
        self.speaker_draw_stage()
        # threads = []
        # self.threads = threads
        # self.Bind(wx.EVT_CLOSE, self.on_exit_app)

        # # connect the client to the server
        # self.connect_to_server()

        # # self.threads.append(Reader(self.srvsock, self))
        # for thread in self.threads:
        #     # stops when everything else does
        #     thread.daemon = True
        #     thread.start()

    # after each window remove the displayed
    # elements from the sizer (not only hide them)
    # This means that new windows won't have sizers from previous sessions?
    # This prevents memory issues
    def remove_elements_from_sizer(self):
        """Remove all elements that were stored in the sizer."""
        for element in self.elements_in_sizer:
            try:
                element.Hide()
                element.Destroy()
            except:
                pass
        self.main_sizer.Clear()

        self.elements_in_sizer = []
        self.Layout()

    # def adjust_dimensions(self, im):
    #     """Adjust the dimension of a given image."""
    #     width = im.GetWidth()
    #     height = im.GetHeight()
    #     ratio = float(width) / float(height)

    #     newwidth = self.image_width * ratio
    #     newheight = self.image_height
    #     return((newwidth, newheight))

    # speaker_draw_stage(self) modifies class GuiWindow (self). Modified properties include:
    # 2 dummy panels (purpose?)
    # drawing panel -> drawer interacts here.

    def speaker_draw_stage(self):
        """Stage were speaker has to 'draw' the line on the grid."""
        # print("In speaker draw stage")

        self.role = "speaker"
        dummy_panel_1 = DummyPanel(self)
        drawing_panel = DrawingPage(self)
        dummy_panel_2 = DummyPanel(self)

        self.main_sizer.Add(dummy_panel_1, 1, wx.ALIGN_CENTER)
        self.main_sizer.Add(drawing_panel, 0, wx.ALIGN_CENTER)
        self.main_sizer.Add(dummy_panel_2, 1, wx.ALIGN_CENTER)

        self.SetSizer(self.main_sizer)
        self.Layout()
        self.elements_in_sizer.append(drawing_panel)


# DrawingPage class takes in a Panel object. Panels inherit from Window. It's a window where controls are placed
# and is usually placed within a Frame.
# This class also draws heavily on wx.grid.Grid
# Do none of these classes have methods they need to implement?
# Where are all these methods called? What is an Event?
# 9 methods
# 1) OnMotion(self,event) -> nothing happens
# 2) CreateFeedbackGrid(self) -> What does the feedback grid do?
# 3) OnClick(self,event) -> Updates grid_list and clicked.
# 4) OnDClick(self,event) -> Essentially the same as OnClick() but takes into account whether grid has been submitted.
# 5) CheckValue(self,coords) -> Where is this used? How does DrawingPage interact with GuiWindow?
# 5) CheckValue(self,coords) -> Where is this used? How does DrawingPage interact with GuiWindow?
# Makes sure that clicks are within threshold. If AllowErase = True, set grid square to white. Else set to black.
# AllowErase is a field in GuiWindow.

# tell the server there's been a click
# self.gui.srvsock.send(self.gui.encode_msg("6666"+ str(tuple(coords)) +"6666"))
# set the cell color to black if there's been enough clicks
# CellValue = self.grid.GetCellValue(*coords)

# 6) add_submit_button(self,label) -> defines a submit button
# 7) OnSubmit(self,event) -> Triggered on clicking submission button; turns canClick to false (no more updating
# grid_list) and calls CreateFeedbackGrid().
# 8) close_up(self) -> closes client
# 9) on_exit_app(self,event) -> why is this needed?
# Fields are:
# grid_list -> an array of 2D arrays that stores the coordinates of clicked cells.
# clicked -> stores the clicked status of the whole grid (for a timer).
# canClick -> allows cells to be clicked before (not after) submission.
# FBGrid -> the grid that the receiver sees (if there is noise)

# Implement client/server structure -> replace with this code
# Implement noise -> for every given square you've clicked on, there is some probability of sending that square.
# Could do it by implementing noise when it's clicked on
# OR implementing it with a method that takes in and manipulates the Grid object

class DrawingPage(wx.Panel):
    """Panel for grid drawing."""
    drawLock = threading.Lock()

    def __init__(self, parent):
        """Initialise the grid."""
        wx.Panel.__init__(self, parent)
        self.gui = parent

        self.clicked = False
        self.CanClick = True
        self.drawnFeedbackGrid = False

        self.ver_box_sizer = wx.BoxSizer(wx.VERTICAL)

        self.SetSizer(self.ver_box_sizer)
        self.ver_box_sizer.Fit(self)
        self.ver_box_sizer.Layout()
        self.Center()

        self.hor_box_sizer = wx.BoxSizer(wx.HORIZONTAL)

        # Initialize vector of filled values to transmit
        # self.fill_vector = [0]*self.gui.GridWidth*self.gui.GridHeight

        # Pics to display

        # self.image_1 = os.path.join(self.gui.image_path,"image-1a.png")
        # # self.image_2 = os.path.join(self.gui.image_path,"image-1b.png")
        # self.pic_1 = wx.Image(self.image_1)
        # # self.pic_2 = wx.Image(self.image_2)
        # self.dimensions_1 = self.gui.adjust_dimensions(self.pic_1)
        # self.pic_1.Rescale(int(self.dimensions_1[0]), int(self.dimensions_1[1]))
        # self.bmap_1 = wx.Bitmap(self.pic_1)
        # self.image_1 = wx.StaticBitmap(self, wx.ID_ANY, self.bmap_1, style=wx.BORDER_SIMPLE)
        # wx.lib.colourdb.updateColourDB() # adds more colors; we want to highlight the chosen pic
        # self.image_1.SetBackgroundColour(wx.Colour('PALE GREEN'))
        # self.dimensions_2 = self.gui.adjust_dimensions(self.pic_2)
        # self.pic_2.Rescale(self.dimensions_2[0], self.dimensions_2[1])
        # self.bmap_2 = wx.Bitmap(self.pic_2)
        # self.image_2 = wx.StaticBitmap(self, wx.ID_ANY, self.bmap_2)

        # Create a wxGrid object and a timer display, add them to sizer
        # self.allowed_time = 30
        # self.remaining = self.allowed_time
        # self.timer_display = wx.StaticText(self, label="You have %s seconds from your first click!" % str(self.remaining))
        self.referent_display = wx.StaticText(self, label="Flower")
        self.grid = wx.grid.Grid(self, -1, style=wx.BORDER_SIMPLE)
        # self.ver_box_sizer.Add(self.timer_display,0)
        self.ver_box_sizer.Add(self.referent_display, 0)
        # self.hor_box_sizer.Add(self.image_1,0)
        # # self.hor_box_sizer.Add(self.image_2,0)
        self.hor_box_sizer.Add(self.grid, 0)
        self.ver_box_sizer.Add(self.hor_box_sizer, 1)
        self.GridRowSize = 40
        self.GridColSize = 40

        # Create the timer
        # self.timer = wx.Timer(self)
        # self.Bind(wx.EVT_TIMER, self.update, self.timer)

        # Add submit button
        self.add_submit_button("Send")

        # Then we call CreateGrid to set the dimensions of the grid
        self.grid.CreateGrid(self.gui.GridWidth, self.gui.GridHeight)
        self.grid.SetDefaultColSize(self.GridRowSize)
        self.grid.SetDefaultRowSize(self.GridColSize)
        self.grid.SetRowLabelSize(0)
        self.grid.SetColLabelSize(0)
        self.grid.SetCellHighlightROPenWidth(0)
        self.grid.ShowScrollbars(wx.SHOW_SB_NEVER, wx.SHOW_SB_NEVER)
        # self.grid.AutoSize() # <--This may have to change

        self.grid_list = []

        # Make all cells read-only
        for m in range(0, self.gui.GridWidth):
            self.grid_list.append([])
            for n in range(0, self.gui.GridHeight):
                self.grid_list[m].append(0)
                self.grid.SetReadOnly(m, n)
                # self.grid.SetCellTextColour(m, n, "white")
                # self.grid.SetCellValue(m,n,str(0))

        # Bind clicking events
        self.Bind(wx.grid.EVT_GRID_CELL_LEFT_CLICK, self.OnClick)
        # self.Bind(wx.grid.EVT_GRID_CELL_LEFT_DCLICK, self.OnDClick)
        # self.Bind(wx.grid.EVT_GRID_RANGE_SELECT, self.OnDragSelect)

        self.grid.GetGridWindow().Bind(wx.EVT_MOTION, self.OnMotion)  # prevent drag selection
        # self.grid.GetGridWindow().Bind(wx.EVT_SCROLLWIN, self.OnScroll) #prevent drag selection

        # Clicks parameter
        self.ClickThreshold = 1

        # self.Show()

    def OnMotion(self, event):
        pass

    # def OnScroll(self,event):
    #     print("scroll")
    #     event.Skip()

    # def OnDragSelect(self,event):
    #     # DrawingPage.drawLock.acquire()
    #     # print("OnDragSelect")
    #     self.grid.ClearSelection()
    #     # DrawingPage.drawLock.release()

    def CreateFeedbackGrid(self):
        if (self.drawnFeedbackGrid == True):
            print("Feedback grid drawn at least once")
            pass
        else:
            self.drawnFeedbackGrid == True
            print("Feedback grid drawn first time")
            self.FBgrid = wx.grid.Grid(self, -1, style=wx.BORDER_SIMPLE)

            self.FBgrid.CreateGrid(self.gui.GridWidth, self.gui.GridHeight)
            self.FBgrid.SetDefaultColSize(int(self.GridColSize / 1.5))
            self.FBgrid.SetDefaultRowSize(int(self.GridRowSize / 1.5))
            self.FBgrid.SetRowLabelSize(0)
            self.FBgrid.SetColLabelSize(0)
            self.FBgrid.SetCellHighlightROPenWidth(0)
            self.FBgrid.ShowScrollbars(wx.SHOW_SB_NEVER, wx.SHOW_SB_NEVER)

            self.FBgrid.GetGridWindow().Bind(wx.EVT_MOTION, self.OnMotion)  # prevent drag selection

            self.hor_box_sizer.Add(self.FBgrid, 0)
            self.hor_box_sizer.Fit(self)
            # self.ver_box_sizer.Add(self.hor_box_sizer,0)
            # self.SetSizer(self.ver_box_sizer)
            self.ver_box_sizer.Fit(self)

            # Sets all cells in grid to ReadOnly.
            for m in range(0, self.gui.GridWidth):
                for n in range(0, self.gui.GridHeight):
                    self.FBgrid.SetReadOnly(m, n)
                    value = self.grid_list[m][n]
                    if int(value) % 2 != 0:
                        self.FBgrid.SetCellTextColour(m, n, wx.Colour("black"))
                        self.FBgrid.SetCellBackgroundColour(m, n, wx.Colour("black"))
            self.FBgrid.Refresh()



    def OnClick(self, event):
        DrawingPage.drawLock.acquire()
        # print("OnClick")
        if self.clicked == False:
            self.clicked = True
            # self.gui.srvsock.send(self.gui.encode_msg("6666FIRSTCLICK6666"))
            # self.StartTimer()
            # self.timer_display.SetLabel("%s seconds left!" % str(self.remaining))
        if self.CanClick == True:
            CellCoords = [event.GetRow(), event.GetCol()]
            # print("CellCoords",CellCoords)
            CellValue = self.grid_list[CellCoords[0]][CellCoords[1]]
            # CellValue = self.grid.GetCellValue(*CellCoords)
            # self.grid.SetCellTextColour(CellCoords[0],CellCoords[1], "white") #Quick hack to stop bug where numbers sometimes visible
            # self.grid.SetCellValue(CellCoords[0],CellCoords[1],str(int(CellValue)+1))
            self.grid_list[CellCoords[0]][CellCoords[1]] += 1
            self.CheckValue(CellCoords)
            # print("Just checked value for OnClick")
        else:
            pass
        DrawingPage.drawLock.release()

    #
    def OnDClick(self, event):
        DrawingPage.drawLock.acquire()
        # print("double clicking")
        # print "OnDClick: ", self.grid_list
        if self.CanClick == True:
            CellCoords = [event.GetRow(), event.GetCol()]
            CellValue = self.grid_list[CellCoords[0]][CellCoords[1]]
            self.grid.SetCellTextColour(CellCoords[0], CellCoords[1],
                                        "white")  # Quick hack to stop bug where numbers sometimes visible
            # self.grid.SetCellValue(CellCoords[0],CellCoords[1],str(int(CellValue)+1))
            self.grid_list[CellCoords[0]][CellCoords[1]] += 1
            self.CheckValue(CellCoords)
        else:
            pass
        DrawingPage.drawLock.release()

    def CheckValue(self, coords):

        # print("coords",coords)
        # tell the server there's been a click
        # self.gui.srvsock.send(self.gui.encode_msg("6666"+ str(tuple(coords)) +"6666"))
        # set the cell color to black if there's been enough clicks
        # CellValue = self.grid.GetCellValue(*coords)

        CellValue = self.grid_list[coords[0]][coords[1]]
        # print("just got CellValue")
        if int(CellValue) >= self.ClickThreshold:
            # print("over threshold")
            CellValue = self.grid_list[coords[0]][coords[1]]
            # print("got Cellvalue again")
            self.grid.SetCellValue(coords[0], coords[1], "")
            if self.gui.AllowErase == True and int(CellValue) % 2 == 0:
                self.grid.SetCellTextColour(coords[0], coords[1], wx.Colour("white"))
                self.grid.SetCellBackgroundColour(coords[0], coords[1], wx.Colour("white"))
            else:
                self.grid.SetCellTextColour(coords[0], coords[1], wx.Colour("black"))
                self.grid.SetCellBackgroundColour(coords[0], coords[1], wx.Colour("black"))
            # print(self.fill_vector)
            # self.fill_vector[(coords[0]*self.gui.GridWidth)+coords[1]] = 1
            # print(self.fill_vector)
            self.grid.Refresh()
        # print("just refreshed")

    # def StartTimer(self):
    #     self.timer.Start(self.allowed_time)

    # def update(self, event):
    #     # print("update")
    #     self.remaining -= 1
    #     if self.remaining < 1:
    #         pass
    #         # if self.gui.hard_mode:
    #         #     print("clearing out grid")
    #         #     self.fill_vector = [0]*(self.gui.GridWidth*self.gui.GridHeight) # clear out the grid in hard mode
    #         # self.gui.submitted_message = self.fill_vector
    #         # self.gui.submit_message()
    #         # self.timer.Stop()
    #     else:
    #         self.timer_display.SetLabel("%s seconds left!" % str(self.remaining))

    def add_submit_button(self, label):
        """Add a submit button. Its position is set.

        :param label: the text written on the button.
        :type label: str.
        """
        submit_button = wx.Button(self, id=wx.ID_ANY,
                                  label=label,
                                  size=self.gui.submit_button_size)
        self.ver_box_sizer.Add(submit_button, 0)
        # when the participant clicks on the button, the on_submit()
        # method is called
        submit_button.Bind(wx.EVT_BUTTON, self.OnSubmit)
        submit_button.Show()
        self.gui.elements_in_sizer.append(submit_button)

    def OnSubmit(self, event):
        self.CanClick = False
        self.drawnFeedbackGrid = False
        self.CreateFeedbackGrid()
        # self.gui.submitted_message = self.fill_vector
        # self.gui.submit_message()

    def close_up(self):
        """Close everything."""
        # self.srvsock.close()
        msg = "closing client"
        pub.sendMessage("clientclosed", data=msg)
        self.Destroy()
        sys.exit()

        # comment this section out if you don't want run_client to remember
        # the ip next time
        # try:
        # os.remove('temp_ip')
        # except(WindowsError):
        # pass

    def on_exit_app(self, event):
        """A dummy function that runs if user tries to close the gui."""
        pass


class DummyPanel(wx.Panel):
    """Dummy panel for getting elements in the middle of the page."""

    def __init__(self, parent):
        """Initialise panel with welcome message."""
        wx.Panel.__init__(self, parent)
        self.gui = parent
        self.ver_box_sizer = wx.BoxSizer(wx.VERTICAL)

        # text = wx.StaticText(self, wx.ID_ANY, label="TEST")
        # self.ver_box_sizer.Add(text, 0)

        self.SetSizer(self.ver_box_sizer)
        # self.ver_box_sizer.Fit(self)
        self.ver_box_sizer.Layout()
        self.Center()


# The wx.App class represents the application and is used to:
# bootstrap the wxPython system and initialize the underlying gui toolkit
# set and get application-wide properties
# implement the native windowing system main message or event loop, and to dispatch events to window instances
# How does App interface with Frame and Window?
class App(wx.App):
    """The wx.Python application that starts the client gui."""

    def OnInit(self):
        """Initialise the client setup frame.

        Unfortunately this method's name has to be uppercase, because it's
        wxPython (does not work with lower case letters).
        """
        self.frame = GuiWindow(parent=None, id=wx.ID_ANY, title="", host="", name="")
        self.frame.Show()
        self.SetTopWindow(self.frame)
        return True


if __name__ == "__main__":
    app = App()
    app.MainLoop()

# Can play around with this



